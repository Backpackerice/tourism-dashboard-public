dyquick =
   ## A quick way to add dygraphs that handles many things for you,
   ##   such as computing rolling averages, getting formatting right
   ##   and registering the dygraph for export to png.
   ## Requires "dygraph-extra-shiny.R", "dygraph-extra.js" and "accounting.min.js"
   ##
   ## Arguments:
   ## -curdat-
   ## A list with elements "date" and "num"
   ## "date" contains a Date vector
   ## "num" contains a matrix or data.frame with the data to plot,
   ##   the columns of "num" must be named as these names are used
   ##   to name the series in the plot.
   ##
   ## -todraw-
   ## One of: "Obs", "RA" or "Both"
   ## "Obs" directly plots the data
   ## "RA" plots the Rolling Averages of the data
   ## "Both" plots both
   ##
   ## -RAperiod-
   ## The period over which the Rolling Average should be computed:
   ##  = 12 for Monthly
   ##  = 4 for Quarterly
   ##  = 1 for Yearly
   ## Additionally, setting RAperiod = 1 ensures that the x labels
   ##   are always years, and not some other breakdown automatically
   ##   generated by dygraphs (which can be confusing).
   ##
   ## -type-
   ## The type of numbers being plotted, to decide how it is formatted.
   ##  = "number" formats as a number
   ##  = "dollar" prefixes a "$" sign
   ##  = "percent" formats as a number with a "%" unit-suffix
   ## Additionally supports the following suffixes:
   ##  = "-m", "-b", etc. are directly passed as a unit-suffix
   ##                     these do not adjust the values themselves
   ##  = "-dp1", "-dp2", etc. are used to set the precision level
   ## e.g.
   ##  = "number-dp2" => 0.00, 0.25, 0.50, 0.75, 1.00
   ##  = "percent" => 10%, 20%, 30%
   ##  = "dollar-m" => $10m, $20m, $30m
   ##
   ## -pal-
   ## The colour palette to use, should be a named vector of colours.
   ## When plotting a series, the function will look for the matching name
   ##   in pal to grab the colour. The same colour is used for all instances
   ##   of the series (i.e. both Obs and RA will be the same colour).
   ## Consider using the `paldy` function in `helper_funcs.R` for generating
   ##   an appropriate palette to use here.
   ##
   ## -ylab-
   ## The label for the y axis
   ##
   ## -title-
   ## The title over the top of the graph. This title may also be used elsewhere
   ##   e.g. when exporting the dygraph as a png, the title can be used to
   ##          generate the file name of the png.
   ##
   ## -labelsDiv-
   ## ID of the div to display the legend. If NULL, labels are shown within
   ##   the dygraph window.
   ##
   ## -labelsSeparateLines-
   ## Logical (TRUE/FALSE) that determines if there should be linebreaks
   ##   between each entry of the legend.
   ##
   ## -labelsShow-
   ## Passed to `dyLegend` function's `show` argument
   ##
   ## -events-
   ## For adding event lines.
   ## Argument should be a list containing lists, each list is passed
   ##   to the `dyEvent` function via `do.call`
   ## e.g.
   ##   list(list(x = "2013-08-01", label = "IVS revision 2013", labelLoc = "top"))
   ## Will display a single event line at "2013-08-01" with the label "IVS revision 2013"
   ##
   ## -stacked-
   ## Logical (TRUE/FALSE) determining if the plot is a stacked graph or not.
   ##
   ## -dateWindow-
   ## The initial date window.
   ## Can be set to "input$dygraphID_date_window" to "remember"
   ##   the date window as inputs are changed. This should be isolated.
   ## e.g. dateWindow = isolate(input$iactnights_date_window)
   function(curdat, todraw, RAperiod, type, pal, ylab, title,
            labelsDiv = NULL, labelsSeparateLines = TRUE, labelsShow = "always",
            events = NULL, stacked = FALSE, dateWindow = NULL){
      ## Define a sub-function to parse the "type" argument
      ## Accepts the argument "type" and returns a JavaScript
      ##  formatting function as a character vector of length 1.
      getformat = function(type){
         ## Split out suffixes
         typesplit = strsplit(type, "-")[[1]]
         typelist = list(
            type = typesplit[1],
            dp = 0,
            unit = ""
         )
         ## Handle extras
         if(length(typesplit) > 1)
            for(i in 2:length(typesplit)){
               curbit = typesplit[i]
               if(substr(curbit, 0, 2) == "dp")
                  typelist$dp = as.numeric(substr(curbit, 3, nchar(curbit)))
               else
                  typelist$unit = curbit
            }
         ## Handle special types
         if(typelist$type == "percent")
            typelist$unit = "%"
         ## Generate format function
         paste0(
            "function(number){return accounting.",
            switch(typelist$type,
               "number" = "formatNumber",
               "dollar" = "formatMoney",
               "percent" = "formatNumber"
            ),
            "(number", paste0(", {precision: ", typelist$dp, "})"),
            paste0(" + ", encodeString(typelist$unit, quote = "'")),
            ";}"
         )
      }
      yformat = getformat(type)
      
      ## Create Obs and/or RA versions of the data
      ##  and merge together into a padded xts
      list_num = list()
      if(todraw == "Obs" || todraw == "Both"){
         list_num[[1]] = curdat$num
      }
      if(todraw == "RA" || todraw == "Both"){
         roll_num = apply(curdat$num, 2, function(x)
            if(length(x) > RAperiod) rollmean(x, RAperiod, fill = NA, align = "right")
            else rep(NA, length = length(x))
         )
         colnames(roll_num) = paste(colnames(roll_num), "(12-mth)")
         list_num[[2]] = roll_num
      }
      merged_xts = padxts(xts(do.call(cbind, list_num), curdat$date))
      
      ## Check if date window is valid
      ## Restrict to dates where there is data
      if(!is.null(dateWindow)){
         dateWindow = as.Date(dateWindow)
         if(dateWindow[1] < first(index(merged_xts))) dateWindow[1] = first(index(merged_xts))
         if(dateWindow[2] > last(index(merged_xts))) dateWindow[2] = last(index(merged_xts))
      }
         
      ## Init
      out_dy = dygraph(merged_xts, ylab = ylab, main = title) %>%
         dyAxis("y", valueRange = if(stacked) c(0, NA) else NULL,
            valueFormatter = yformat, axisLabelFormatter = yformat, axisLabelWidth = 80)
      
      ## If period is yearly, force x labels to only display years
      if(RAperiod == 1){
         xticks = paste0("[",
            paste0("{label: '", format(curdat$date, "%Y"), "', ",
                   "v: Dygraph.dateStrToMillis('", curdat$date, "')}",
                   collapse = ", "), "]")
         out_dy = dyAxis(out_dy, "x", ticker = paste0("function(){return ", xticks, ";}"))
      }
      
      ## Plot each series
      for(curvar in names(curdat$num)){
         curcol = pal[[curvar]]
         if(todraw == "Both"){
            out_dy = out_dy %>%
               dySeries(curvar, strokePattern = "dotted", color = curcol) %>%
               dySeries(paste(curvar, "(12-mth)"), strokeWidth = 3, color = curcol)
         } else if(todraw == "Obs"){
            out_dy = dySeries(out_dy, curvar, color = curcol)
         } else if(todraw == "RA"){
            out_dy = dySeries(out_dy, paste(curvar, "(12-mth)"), color = curcol)
         }
      }
      
      ## Set Highlight options
      out_dy = dyHighlight(out_dy, highlightSeriesOpts =
         list(strokeWidth = if(todraw == "Both") 5 else 3, strokeBorderWidth = 2))
      if(stacked)
         out_dy = dyHighlight(out_dy, highlightSeriesBackgroundAlpha = 1)
      
      ## Events
      if(!is.null(events))
         for(i in 1:length(events))
            out_dy = do.call(dyEvent, c(list(out_dy), events[[i]]))
      
      ## Finish
      out_dy = out_dy %>%
         dyRangeSelector(dateWindow = dateWindow) %>%
         dyLegend(show = labelsShow, labelsDiv = labelsDiv, labelsSeparateLines = labelsSeparateLines) %>%
         dyCallbacks(drawCallback = dyRegister()) %>%
         dyOptions(rightGap = 25, stackedGraph = stacked)
      
      renderDygraph(out_dy)
   }

rte_dyquick =
   ## A wrapper specifically for dygraphs for some RTE pages
   ## Separate as it is migrated from what used to be a standalone RTE app
   function(spread_rte, pal, title, labelsDiv = NULL, stacked = FALSE, dateWindow = NULL){
      datevec = as.Date(paste0("31-03-", spread_rte[,1]), format = "%d-%m-%Y")
      xts_rte = xts(spread_rte[,-1,drop=FALSE], datevec)
      xticks = paste0("[",
         paste0("{label: '", spread_rte[,1], "', ",
                "v: Dygraph.dateStrToMillis('", datevec, "')}",
                collapse = ", "), "]")
      if(stacked){
         ylab = "Share of Total Spend"
         ## Compute an appropriate precision based on maximum value
         mbt = log10(max(xts_rte, na.rm = TRUE)) - 1
         yprec = if(mbt < 0) ceiling(abs(mbt)) else 0
         yformat = paste0("function(number){",
         "   return accounting.formatNumber(number,", yprec, ") + '%';",
         "}")
      } else{
         ylab = "Spend"
         ## Compute an appropriate precision based on minimum value
         mbt = log10(min(xts_rte, na.rm = TRUE)) - 1
         yprec = if(mbt < 0) ceiling(abs(mbt)) else 0
         yformat = paste0("function(number){",
         "   return accounting.formatMoney(number, {precision:", yprec, "}) + 'm';",
         "}")
      }
      
      ## Init
      out_dy = xts_rte %>%
         padxts() %>%
         dygraph(ylab = ylab, main = title) %>%
         dyAxis("x", rangePad = 5, ticker = paste0("function(){return ", xticks, ";}")) %>%
         dyHighlight(highlightSeriesOpts = list(strokeWidth = 3, strokeBorderWidth = 2))
      
      ## Specify y axis
      if(stacked)
         out_dy = out_dy %>%
            dyAxis("y", valueRange = c(0, NA), valueFormatter = yformat, axisLabelFormatter = yformat, axisLabelWidth = 80) %>%
            dyHighlight(highlightSeriesBackgroundAlpha = 1)
      else
         out_dy = out_dy %>%
            dyAxis("y", valueFormatter = yformat, axisLabelFormatter = yformat, axisLabelWidth = 80)
      
      ## Finish
      out_dy = out_dy %>%
         dyRangeSelector(dateWindow = dateWindow) %>%
         dyLegend(show = "always", labelsDiv = labelsDiv, labelsSeparateLines = TRUE) %>%
         dyCallbacks(drawCallback = dyRegister())
      
      ## Stacked
      if(stacked)
         out_dy = dyOptions(out_dy, rightGap = 25, colors = pal, axisLineColor = "rgba(0, 0, 0, 0)", stackedGraph = TRUE)
      else
         out_dy = dyOptions(out_dy, rightGap = 25, colors = pal, axisLineColor = "rgba(0, 0, 0, 0)")
      
      renderDygraph(out_dy)
   }

cas_dyquick =
   ## A wrapper specifically for dygraphs for the CAS page
   ## Separate as it is migrated from what used to be a standalone CAS app
   function(curdat, todraw, title, labelsDiv = NULL, stackedperc = FALSE){
      if(todraw == "Obs"){
         draw_num = curdat$num
      }
      if(todraw == "RA"){
         draw_num = apply(curdat$num, 2, function(x)
            if(length(x) > 4) rollmean(x, 4, fill = NA, align = "right")
            else rep(NA, length = length(x))
         )
         colnames(draw_num) = paste(colnames(draw_num), "(12-mth)")
      }
      percformat0 = "function(number){return accounting.toFixed(number, 0) + '%';}"
      percformat2 = "function(number){return accounting.toFixed(number, 2) + '%';}"
      
      out_dy = xts(draw_num, curdat$date) %>%
         padxts() %>%
         dygraph(main = paste(title, "(Quarterly)")) %>%
         dyRangeSelector() %>%
         dyLegend(show = "always", labelsDiv = labelsDiv) %>%
         dyCallbacks(drawCallback = dyRegister())
      
      if(ncol(curdat$num) > 1)
         out_dy = dyHighlight(out_dy, highlightSeriesBackgroundAlpha = 1, highlightSeriesOpts = list(strokeWidth = 3))
      if(stackedperc)
         out_dy = out_dy %>%
            dyAxis("y", "Percentage", valueRange = c(0, 101), valueFormatter = percformat2, axisLabelFormatter = percformat0) %>%
            dyOptions(rightGap = 25, stackedGraph = TRUE)
      else
         out_dy = dyOptions(out_dy, rightGap = 25)
      
      out_dy
   }

ggstackbar =
   ## A fast way to create stacked barplots in ggvis
   ##
   ## Arguments:
   ## -curdat-
   ## A dataframe with the data to plot
   ## Should have 3 variables for x, y, fill
   ##
   ## -plist-
   ## A list naming the variables to assign to which prop (x, y, fill)
   ## e.g. plist = list(x = "Area", y = "Spend", fill = "Product")
   ##
   ## -titles-
   ## The axes titles for each prop, no titles should be given as ""
   ## e.g. titles = list(x = "", y = "Percentage of spend", fill = "Product")
   ##
   ## -ttips-
   ## Any prefix/suffix to be added for non-scaled tooltips
   ##  (scaled tooltips are always given a "%" suffix and no prefix)
   ## e.g. ttips = c(prefix = "$", suffix = "m")
   ##
   ## -scaled-
   ## TRUE/FALSE, stating whether the data should be scaled or not
   ##
   ## -width- and -height-
   ## Passed to ggvis `set_options` to set plot dimensions
   function(curdat, plist, titles, ttips, scaled = FALSE, width = "auto", height = 600){
      ## Get fill categories and compute appropriate colour palette
      ## Using hcl for now as mbie colours don't look good in a stacked barplot
      catfill = levels(curdat[[plist$fill]])
      ## pal = mbie.cols2(seq(length = length(catfill)))
      pal = hcl(seq(0, 270, length = length(catfill)))
      
      ## Scale data if needed
      if(scaled){
         spread_dat = spread_(curdat, plist$x, plist$y)
         scaled_dat = cbind(spread_dat[1], apply(spread_dat[,-1], 2, function(x) x/sum(x, na.rm = TRUE)))
         curdat = gather_(scaled_dat, plist$x, plist$y, colnames(scaled_dat)[-1])
      }
      
      ## Setup plot
      outvis = ggvis(curdat, x = as.name(plist$x), y = as.name(plist$y), fill = as.name(plist$fill)) %>%
         scale_ordinal("fill", range = pal) %>%
         layer_bars() %>%
         add_legend("fill", values = rev(catfill), title = titles$fill) %>%
         add_axis("x", title = titles$x, tick_size_end = 0, properties =
                  axis_props(labels = list(angle = 270, align = "right"))) %>%
         add_axis("y", title = titles$y, title_offset = 50, tick_size_end = 0) %>%
         set_options(width = width, height = height, duration = 0, renderer = "canvas")
      
      ## Add scale-appropriate tooltips
      if(scaled){
         outvis = outvis %>%
            add_tooltip(function(input){
               if(is.null(input)) return(NULL)
               paste0("<b>", input$x_, "</b><br/>",
                      input[[plist$fill]], " (",
                      round((input$stack_upr_ - input$stack_lwr_) * 100), "%)")
            })
      } else{
         outvis = outvis %>%
            add_tooltip( function(input){
               if(is.null(input)) return(NULL)
               paste0("<b>", input$x_, "</b><br/>",
                      input[[plist$fill]], " (", ttips[["prefix"]],
                      round((input$stack_upr_ - input$stack_lwr_)),
                      ttips[["suffix"]], ")")
            })
      }
      
      outvis
   }

dyforex =
	## A wrapper specifically for dygraphs for the forex page
	## Handles direction flipping, conversion to Index and automatic
	##   computation on an appropriate precision (decimal points)
	##   based on the average absolute difference
   function(curxts, title, pal, labelsDiv = NULL, dateWindow = NULL){
      # fdates = c(format(start(curxts), "%d-%m-%Y"), format(end(curxts), "%d-%m-%Y"))
      ylab = "Index"
      yformat = "function(number){
         return accounting.formatNumber(number);
      }"
      
      ## Plot
      out_dy = curxts %>%
         padxts() %>%
         dygraph(ylab = ylab, main = title) %>%
         dyAxis("y", valueFormatter = yformat, axisLabelFormatter = yformat, axisLabelWidth = 60)
      
      ## Plot each series
      for(curvar in colnames(curxts)){
         curcol = as.vector(pal[curvar])
         out_dy = dySeries(out_dy, curvar, color = curcol)
      }
      
      ## If index, add limit line at 100
      if(ncol(curxts) > 1) out_dy = dyLimit(out_dy, 100, color = "grey")
      
      ## Finish
      out_dy = dyHighlight(out_dy, highlightSeriesOpts = list(strokeWidth = 3, strokeBorderWidth = 2)) %>%
         dyRangeSelector(dateWindow = dateWindow) %>%
         dyLegend(show = "always", labelsDiv = labelsDiv, labelsSeparateLines = TRUE) %>%
         dyCallbacks(drawCallback = dyRegister()) %>%
         dyOptions(connectSeparatedPoints = TRUE)
      
      renderDygraph(out_dy)
   }
